{"version":3,"file":"geo-viewport.cjs","sources":["../lib/index.ts"],"sourcesContent":["import SphericalMercator from \"@mapbox/sphericalmercator\";\n\nfunction getAdjusted(base: number, ratios: Ratios, allowFloat: boolean) {\n  const adjusted = Math.min(\n    base - Math.log(ratios[0]) / Math.log(2),\n    base - Math.log(ratios[1]) / Math.log(2)\n  );\n\n  return allowFloat ? adjusted : Math.floor(adjusted);\n}\n\ntype Ratios = [number, number];\n\n/**\n * Viewport dimensions, in pixel units\n */\nexport type Dimensions = [number, number];\n\n/**\n * A center point, either as an object, or as an array.\n * The array must be in Longitude, Latitude order, as is the custom.\n */\nexport type LongitudeLatitude = Position | { lon: number; lat: number };\n\n/**\n * A Longitude, Latitude position, in that order.\n */\nexport type Position = [number, number];\n\n/**\n * A bounding rectangle, in WSEN order\n */\nexport type Bounds = [number, number, number, number];\n\nexport interface Viewport {\n  center: Position;\n  zoom: number;\n}\n\n/**\n * Given bounds in WSEN order and pixel dimensions,\n * figure out what center and zoom will produce a map\n * view with the same bounds and dimensions.\n */\nexport function viewport(\n  bounds: Bounds,\n  dimensions: Dimensions,\n  {\n    minzoom = 0,\n    maxzoom = 20,\n    tileSize = 256,\n    allowFloat = false,\n    allowAntiMeridian = false,\n  }: {\n    minzoom?: number;\n    maxzoom?: number;\n    tileSize?: number;\n    /**\n     * Allow floating-point zoom levels. By default,\n     * only integer zoom levels are output.\n     */\n    allowFloat?: boolean;\n    allowAntiMeridian?: boolean;\n  } = {}\n): Viewport {\n  const merc = new SphericalMercator({\n    size: tileSize,\n    antimeridian: allowAntiMeridian,\n  });\n  const base = maxzoom;\n  const bl = merc.px([bounds[0], bounds[1]], base);\n  const tr = merc.px([bounds[2], bounds[3]], base);\n  const width = tr[0] - bl[0];\n  const height = bl[1] - tr[1];\n  const centerPixelX = bl[0] + width / 2;\n  const centerPixelY = tr[1] + height / 2;\n  const ratios: Ratios = [width / dimensions[0], height / dimensions[1]];\n  const adjusted = getAdjusted(base, ratios, allowFloat);\n\n  const center = merc.ll([centerPixelX, centerPixelY], base);\n  const zoom = Math.max(minzoom, Math.min(maxzoom, adjusted));\n\n  return { center, zoom };\n}\n\n/**\n * The inverse of viewport: given center, zoom,\n * dimensions, and tileSize, return the bounds that will be produced\n * when you configure a map with those parameters.\n */\nexport function bounds(\n  center: LongitudeLatitude,\n  zoom: number,\n  dimensions: [number, number],\n  tileSize: number = 256\n): Bounds {\n  if (!Array.isArray(center)) {\n    center = [center.lon, center.lat];\n  }\n\n  const merc = new SphericalMercator({\n    size: tileSize,\n  });\n  const px = merc.px(center, zoom);\n  const tl = merc.ll(\n    [px[0] - dimensions[0] / 2, px[1] - dimensions[1] / 2],\n    zoom\n  );\n  const br = merc.ll(\n    [px[0] + dimensions[0] / 2, px[1] + dimensions[1] / 2],\n    zoom\n  );\n  return [tl[0], br[1], br[0], tl[1]];\n}\n"],"names":[],"mappings":"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"}